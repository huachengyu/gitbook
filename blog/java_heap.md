### Java内存区域解析
@Date 2017.05.24

> 概念介绍(基于JDK7)

* 堆(分代收集算法)
    1. 年轻代(Minor GC)
        * Eden区
            * 存储新对象或者生命周期很短的对象
        * From Survivor区
            * Eden区的垃圾回收仍能存活下来的依旧存在引用的对象会待在这个区域
        * To Survivor区
            * Eden区的垃圾回收仍能存活下来的依旧存在引用的对象会待在这个区域
    2. 年老代
        * Eden区和Survivor区的多次GC后仍然存活下来的对象 - major GC
        * 内存大小为-Xmx对应的值减去-Xmn对应的值
        * 新建的对象也有可能直接进入老年代
            1. 大对象:可通过启动参数设置-XX:PretenureSizeThreshold超过则直接在老年代分配
            2. 大的数组对象,且数组中无引用外部对象
        
* 方法区(Non-Heap(非堆))
    1. 永久代(HotSpot VM)
        * 各个线程共享的内存区域
        * 方法区是线程安全的
        * 存储已被虚拟机加载的类信息、方法（数据及代码）、常量、静态变量、即时编译器编译后的代码等数据
    2. 运行时常量池(Runtime Constant Pool)
        * 存放编译期生成的各种字面量和符号引用
        * 运行期间也可能将新的常量放入池中
        * String类的intern()方法
        
* 栈
    1. 虚拟机栈
        * 方法执行的内存模型
        * 每个线程都有自己专属的栈,这个栈是别的线程无法访问的
        * 生命周期与线程相同
        * 存储局部变量表(存放方法参数和方法内部定义的局部变量)、操作栈、动态链接、方法出口、方法调用的中间结果及返回地址
        * 线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常
        * 虚拟机栈可动态扩展,当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常
        
* 本地方法栈
    * 为虚拟机使用到的Native方法服务    
    
* 计数器
    1. 程序计数器
        * 分支、循环、跳转、异常处理、线程恢复
        * 每条线程都需要有一个独立的程序计数器
        * JVM执行的字节码指令地址
        * 当前线程所执行的字节码的行号指示器
        * 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
        * 此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域

* 直接内存(Direct Memory)
    1. NIO出现后使用
        * 本机直接内存的分配不会受到Java堆大小的限制

> 持久代 --> 元空间 (JDK8)

* 元空间
    1. 本地堆内存中的一部分
    2. 达到最大阈值时进行该区域清理
    3. 类及相关的元数据的生命周期与类加载器的一致
    4. 使用-XX:MaxMetaspaceSize参数可以设置元空间的最大值
    5. 默认是没有上限的,系统内存上限是多少它就是多少
    6. 达到设定的最大值后,对于无用的类和类加载器,垃圾收集此时会触发
    
> Error
 * 内存溢出(Out Of Memory) : 程序在申请内存时,没有足够的内存空间供其使用
 * 内存泄露(Memory Leak) : 程序在申请内存后,无法释放已申请的内存空间.一次内存泄露可以忽略,泄露堆积后果很严重,最终会导致Out Of Memory.